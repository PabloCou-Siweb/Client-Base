================================================================================
  ENDPOINT PARA CAMBIO DE CONTRASEÑA - CLIENTBASE
================================================================================

MÉTODO: PUT
RUTA: /api/auth/change-password

================================================================================
  HEADERS
================================================================================
{
  "Authorization": "Bearer {token}",
  "Content-Type": "application/json"
}

================================================================================
  BODY (REQUEST)
================================================================================
{
  "currentPassword": "contraseña_actual",
  "newPassword": "nueva_contraseña",
  "confirmPassword": "nueva_contraseña"
}

================================================================================
  RESPUESTA EXITOSA (200 OK)
================================================================================
{
  "message": "Contraseña actualizada correctamente"
}

================================================================================
  ERRORES POSIBLES
================================================================================

1. Contraseña actual incorrecta (400 Bad Request):
{
  "error": "La contraseña actual es incorrecta",
  "statusCode": 400
}

2. Las contraseñas no coinciden (400 Bad Request):
{
  "error": "Las contraseñas no coinciden",
  "statusCode": 400
}

3. Contraseña muy corta (400 Bad Request):
{
  "error": "La nueva contraseña debe tener al menos 6 caracteres",
  "statusCode": 400
}

4. Usuario no autenticado (401 Unauthorized):
{
  "error": "No autorizado",
  "statusCode": 401
}

================================================================================
  VALIDACIONES EN EL BACKEND
================================================================================

1. Verificar que el token JWT sea válido
2. Obtener el usuario autenticado del token
3. Verificar que currentPassword coincida con la contraseña hasheada en BD
   - Usar bcrypt.compare(currentPassword, user.password)
4. Verificar que newPassword === confirmPassword
5. Verificar que newPassword tenga al menos 6 caracteres
6. Hashear newPassword con bcrypt
   - Usar bcrypt.hash(newPassword, 10)
7. Actualizar el campo password del usuario en BD
8. Retornar mensaje de éxito

================================================================================
  EJEMPLO DE IMPLEMENTACIÓN (Node.js + Prisma + bcrypt)
================================================================================

import bcrypt from 'bcrypt';

export const changePassword = async (req, res) => {
  try {
    const { currentPassword, newPassword, confirmPassword } = req.body;
    const userId = req.user.id; // Del token JWT

    // Validaciones
    if (!currentPassword || !newPassword || !confirmPassword) {
      return res.status(400).json({ 
        error: 'Todos los campos son requeridos',
        statusCode: 400 
      });
    }

    if (newPassword !== confirmPassword) {
      return res.status(400).json({ 
        error: 'Las contraseñas no coinciden',
        statusCode: 400 
      });
    }

    if (newPassword.length < 6) {
      return res.status(400).json({ 
        error: 'La nueva contraseña debe tener al menos 6 caracteres',
        statusCode: 400 
      });
    }

    // Obtener usuario
    const user = await prisma.user.findUnique({
      where: { id: userId }
    });

    if (!user) {
      return res.status(404).json({ 
        error: 'Usuario no encontrado',
        statusCode: 404 
      });
    }

    // Verificar contraseña actual
    const isPasswordValid = await bcrypt.compare(currentPassword, user.password);
    if (!isPasswordValid) {
      return res.status(400).json({ 
        error: 'La contraseña actual es incorrecta',
        statusCode: 400 
      });
    }

    // Hashear nueva contraseña
    const hashedPassword = await bcrypt.hash(newPassword, 10);

    // Actualizar contraseña
    await prisma.user.update({
      where: { id: userId },
      data: { password: hashedPassword }
    });

    res.json({ message: 'Contraseña actualizada correctamente' });

  } catch (error) {
    console.error('Error al cambiar contraseña:', error);
    res.status(500).json({ 
      error: 'Error interno del servidor',
      statusCode: 500 
    });
  }
};

================================================================================
  SEGURIDAD IMPORTANTE
================================================================================

1. ✅ Verificar el token JWT en el middleware de autenticación
2. ✅ NUNCA retornar la contraseña en ninguna respuesta
3. ✅ Usar bcrypt para hashear contraseñas (NUNCA texto plano)
4. ✅ Validar todos los campos en el backend
5. ✅ Implementar rate limiting para evitar fuerza bruta
6. ✅ Registrar intentos fallidos en logs (opcional)
7. ✅ Considerar cerrar otras sesiones activas después del cambio (opcional)

================================================================================
  RUTA EN EXPRESS (Ejemplo)
================================================================================

import { authMiddleware } from './middleware/auth';
import { changePassword } from './controllers/auth';

router.put('/auth/change-password', authMiddleware, changePassword);

================================================================================
  MIDDLEWARE DE AUTENTICACIÓN (Ejemplo)
================================================================================

import jwt from 'jsonwebtoken';

export const authMiddleware = (req, res, next) => {
  try {
    const token = req.headers.authorization?.split(' ')[1];
    
    if (!token) {
      return res.status(401).json({ 
        error: 'No autorizado',
        statusCode: 401 
      });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded; // { id, email, role }
    next();
  } catch (error) {
    return res.status(401).json({ 
      error: 'Token inválido',
      statusCode: 401 
    });
  }
};

================================================================================
  ACTUALIZACIÓN DE PERFIL (NOMBRE Y EMAIL)
================================================================================

MÉTODO: PUT
RUTA: /api/auth/profile

HEADERS:
{
  "Authorization": "Bearer {token}",
  "Content-Type": "application/json"
}

BODY (REQUEST):
{
  "name": "Nuevo Nombre",
  "email": "nuevo@email.com"
}

RESPUESTA EXITOSA (200 OK):
{
  "message": "Perfil actualizado correctamente",
  "user": {
    "id": 1,
    "name": "Nuevo Nombre",
    "email": "nuevo@email.com",
    "role": "ADMIN",
    "updatedAt": "2024-01-21T15:45:00.000Z"
  }
}

ERRORES POSIBLES:

1. Email ya en uso (400 Bad Request):
{
  "error": "Este email ya está en uso",
  "statusCode": 400
}

2. Email inválido (400 Bad Request):
{
  "error": "Email inválido",
  "statusCode": 400
}

3. Nombre muy corto (400 Bad Request):
{
  "error": "El nombre debe tener al menos 3 caracteres",
  "statusCode": 400
}

VALIDACIONES EN EL BACKEND:
- Verificar que el email no esté ya en uso por otro usuario
- Validar formato de email
- Validar que el nombre tenga al menos 3 caracteres
- Retornar el usuario actualizado

================================================================================
  NOTAS ADICIONALES
================================================================================

- El frontend valida formato de email antes de enviar
- El frontend valida que las contraseñas coincidan
- El frontend maneja estados de carga separados (isLoading, isUpdatingProfile)
- El frontend muestra mensajes de error individuales por campo
- Los inputs se marcan en rojo cuando hay error
- Los inputs se deshabilitan durante la carga
- Los campos de contraseña se limpian después de un cambio exitoso
- Los errores se limpian al escribir en el campo

