================================================================================
  ENDPOINT PARA SUBIR AVATAR DE USUARIO - CLIENTBASE
================================================================================

MÉTODO: POST
RUTA: /api/auth/upload-avatar

================================================================================
  HEADERS
================================================================================
{
  "Authorization": "Bearer {token}",
  "Content-Type": "multipart/form-data"
}

================================================================================
  BODY (FORM-DATA)
================================================================================
avatar: [archivo de imagen]

================================================================================
  RESPUESTA EXITOSA (200 OK)
================================================================================
{
  "message": "Avatar actualizado correctamente",
  "avatarUrl": "https://example.com/uploads/avatars/user-1-1234567890.jpg"
}

Nota: avatarUrl debe ser la URL pública accesible de la imagen

================================================================================
  ERRORES POSIBLES
================================================================================

1. No se proporcionó archivo (400 Bad Request):
{
  "error": "No se proporcionó ningún archivo",
  "statusCode": 400
}

2. Archivo muy grande (400 Bad Request):
{
  "error": "El archivo es muy grande. Máximo 2MB",
  "statusCode": 400
}

3. Tipo de archivo inválido (400 Bad Request):
{
  "error": "Solo se permiten imágenes (JPG, PNG, GIF)",
  "statusCode": 400
}

4. Usuario no autenticado (401 Unauthorized):
{
  "error": "No autorizado",
  "statusCode": 401
}

5. Error al guardar archivo (500 Internal Server Error):
{
  "error": "Error al guardar el archivo",
  "statusCode": 500
}

================================================================================
  VALIDACIONES EN EL BACKEND
================================================================================

1. Verificar que el token JWT sea válido
2. Verificar que se envió un archivo
3. Validar tamaño del archivo (máximo 2MB = 2 * 1024 * 1024 bytes)
4. Validar tipo de archivo (image/jpeg, image/png, image/gif)
5. Generar nombre único para el archivo (ej: user-{id}-{timestamp}.jpg)
6. Guardar archivo en storage (local, S3, Cloudinary, etc.)
7. Actualizar campo avatarUrl en la base de datos
8. Retornar URL pública del avatar

================================================================================
  EJEMPLO DE IMPLEMENTACIÓN (Node.js + Multer + Prisma)
================================================================================

import multer from 'multer';
import path from 'path';
import fs from 'fs';

// Configurar Multer para subir archivos
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = 'uploads/avatars/';
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const userId = req.user.id;
    const timestamp = Date.now();
    const ext = path.extname(file.originalname);
    cb(null, `user-${userId}-${timestamp}${ext}`);
  }
});

const upload = multer({
  storage: storage,
  limits: {
    fileSize: 2 * 1024 * 1024, // 2MB
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Solo se permiten imágenes (JPG, PNG, GIF)'));
    }
  }
});

// Controlador
export const uploadAvatar = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        error: 'No se proporcionó ningún archivo',
        statusCode: 400
      });
    }

    const userId = req.user.id;
    
    // Construir URL del avatar
    // Opción 1: URL local
    const avatarUrl = `${req.protocol}://${req.get('host')}/uploads/avatars/${req.file.filename}`;
    
    // Opción 2: Si usas un CDN o S3, construir URL apropiada
    // const avatarUrl = `https://tu-bucket.s3.amazonaws.com/avatars/${req.file.filename}`;

    // Actualizar usuario en BD
    const user = await prisma.user.update({
      where: { id: userId },
      data: { avatarUrl }
    });

    res.json({
      message: 'Avatar actualizado correctamente',
      avatarUrl: avatarUrl
    });

  } catch (error) {
    console.error('Error al subir avatar:', error);
    
    // Si Multer detecta archivo muy grande
    if (error.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({
        error: 'El archivo es muy grande. Máximo 2MB',
        statusCode: 400
      });
    }
    
    res.status(500).json({
      error: 'Error al guardar el archivo',
      statusCode: 500
    });
  }
};

================================================================================
  RUTA EN EXPRESS (Ejemplo)
================================================================================

import { authMiddleware } from './middleware/auth';
import { uploadAvatar } from './controllers/auth';
import multer from 'multer';

// Configurar multer (ver arriba)
const upload = multer({ /* configuración */ });

router.post(
  '/auth/upload-avatar',
  authMiddleware,           // Verificar JWT
  upload.single('avatar'),  // Procesar archivo con nombre 'avatar'
  uploadAvatar              // Controlador
);

================================================================================
  SERVIR ARCHIVOS ESTÁTICOS (Express)
================================================================================

Para que las imágenes sean accesibles públicamente:

app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

Esto permite acceder a:
http://localhost:5000/uploads/avatars/user-1-1234567890.jpg

================================================================================
  MODELO PRISMA ACTUALIZADO
================================================================================

model User {
  id        Int      @id @default(autoincrement())
  name      String
  email     String   @unique
  password  String
  role      Role     @default(USER)
  avatarUrl String?  // ← Campo opcional para la URL del avatar
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum Role {
  ADMIN
  USER
}

================================================================================
  CONSIDERACIONES IMPORTANTES
================================================================================

1. SEGURIDAD:
   - Validar SIEMPRE el tipo de archivo en el backend
   - Renombrar archivos para evitar conflictos
   - No confiar en la extensión del archivo
   - Verificar contenido real del archivo (magic bytes)

2. OPTIMIZACIÓN:
   - Considerar redimensionar imágenes (ej: 200x200px)
   - Comprimir imágenes para reducir tamaño
   - Usar librerías como Sharp para procesamiento de imágenes

3. ALMACENAMIENTO:
   - Local: Simple pero no escalable
   - S3/Cloudinary: Recomendado para producción
   - CDN: Para mejor rendimiento

4. LIMPIEZA:
   - Eliminar avatar anterior cuando se sube uno nuevo
   - Implementar tarea de limpieza de archivos huérfanos

5. CORS:
   - Configurar CORS si el frontend está en dominio diferente
   - Permitir acceso a /uploads desde el frontend

================================================================================
  EJEMPLO CON CLOUDINARY (Alternativa a almacenamiento local)
================================================================================

import { v2 as cloudinary } from 'cloudinary';

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET
});

export const uploadAvatar = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No se proporcionó ningún archivo' });
    }

    const userId = req.user.id;
    
    // Subir a Cloudinary
    const result = await cloudinary.uploader.upload(req.file.path, {
      folder: 'avatars',
      public_id: `user-${userId}`,
      overwrite: true,
      transformation: [
        { width: 200, height: 200, crop: 'fill' },
        { quality: 'auto' }
      ]
    });

    // Actualizar usuario
    await prisma.user.update({
      where: { id: userId },
      data: { avatarUrl: result.secure_url }
    });

    res.json({
      message: 'Avatar actualizado correctamente',
      avatarUrl: result.secure_url
    });

  } catch (error) {
    console.error('Error al subir avatar:', error);
    res.status(500).json({ error: 'Error al guardar el archivo' });
  }
};

================================================================================
  FRONTEND - YA IMPLEMENTADO
================================================================================

El frontend ya está configurado para:
- ✅ Seleccionar archivo de imagen
- ✅ Validar tamaño (máx 2MB)
- ✅ Validar tipo (solo imágenes)
- ✅ Enviar como FormData con nombre 'avatar'
- ✅ Actualizar contexto con avatarUrl
- ✅ Mostrar imagen si existe, o iniciales si no
- ✅ Manejar estados de carga
- ✅ Mostrar errores

================================================================================
  TESTING
================================================================================

Probar con:
1. Imagen válida pequeña (< 2MB) - debe funcionar
2. Imagen muy grande (> 2MB) - debe rechazarse
3. Archivo no-imagen (.txt, .pdf) - debe rechazarse
4. Sin token de autenticación - debe retornar 401

================================================================================
  NOTAS ADICIONALES
================================================================================

- El frontend valida tamaño y tipo ANTES de enviar
- El backend DEBE validar también (nunca confiar en frontend)
- Retornar URL completa y accesible públicamente
- El campo avatarUrl es opcional en el modelo User
- Si no hay avatar, el frontend muestra las iniciales del nombre

